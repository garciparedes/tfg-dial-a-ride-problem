% !TEX root = ../../document.tex

\documentclass{subfiles}

\begin{document}

  \chapter{Métodos de Resolución}
  \label{chap:solving}

    \section{Introducción}
    \label{sec:solving_introduction}

      \paragraph{}
      Los problemas de \emph{optimización combinatoria} constituyen una de las categorías más interesantes dentro del área de la optimización de variables. Esto se debe a la gran aplicabilidad de los mismos en situaciones de la vida real, así como la gran reducción de costes que se puede alcanzar cuando estos son aplicados en los puntos estratégicos de cualquier proceso de producción.

      \paragraph{}
      Sin embargo, esta categoría de problemas de optimización presenta un mayor grado de dificultad en su resolución, tal y como se ha indicado a lo largo del \cref{chap:formulation}. Entre otros, esto se debe a la imposibilidad de utilizar técnicas basadas en gradientes (que en problemas con variables de decisión continuas proporcionan simplifican mucho su resolución). Puesto que estas técnicas no son aplicables, la estrategia alternativa se basa en la enumeración de posibles configuraciones de variables de manera inteligente hasta alcanzar aquella que genere el resultado óptimo para la instancia del problema que se pretenda resolver.

      \paragraph{}
      Por tanto, a pesar de no ser posible el apoyo en técnicas basadas en gradientes, si que existe la aternativa basada en enumeración de configuraciones como enfoque para dar con el óptimo. A pesar de ello, es fácil darse cuenta de que esta estrategia no es lo suficientemente potente como para permitir resolver problemas reales (o incluso de pequeño tamaño). La dificultad radica en la explosión combinatoria generada por la enumeración de soluciones. Por ejemplo, en un problema compuesto por $20$ variables de decisión de naturaleza binaria, el número de configuraciones a evaluar alcanzaría el valor de $2^{20} = 1048576$, lo cual no es escalable a problemas de gran tamaño, donde hay cientos o miles de variables de decisión con las que trabajar.

      \paragraph{}
      A pesar de esta dificultad, es posible enfrentarse a problemas de \emph{optimización combinatoria} de tamaños relativamente grande teniendo en cuenta distintas estrategias que permiten ignorar un gran número de configuraciones no factibles dadas las restricciones descritas por el problema en cuestión. Es por ello que muchos de los métodos de resolución se apoyan en estas garantias para enfocar la búsqueda sobre un subespacio de configuraciones factibles. Otra de las ideas más utilizadas por los métodos de resolución es apoyarse en los resultados de evaluación de configuraciones anteriores para que el coste computacional de evaluación de configuraciones actuales sea mucho menor. Dicha estrategia algorítmica se conoce como \emph{Programación Dinámica}, la cual se describe en mayor detalle en \cite{bellman1954theory}.


      \paragraph{}
      A lo largo del capítulo se decriben distintas situaciones en que es posible aplicar las técnicas anteriormente descritas sobre el \emph{problema Dial-a-Ride} para tratar de reducir en la medida de los posible la complejidad computacional que este presenta. Entonces, el resto del capítulo se organiza de la siguiente manera: En el \cref{sec:solving_exacts} se describen las distintas técnicas de resolución exactas que la literatura especializada en el problema a probado para tratar de resolver el problema. Seguidamente, en el \cref{sec:solving_heuristics} se describen estrategia basadas en heurísticas (tanto de construcción como mejora de soluciones) que a pesar de no ofrecer ninguna garantía de optimalidad, ofrecen un buen equilibrio entre tiempo de cómputo y calidad de las soluciones. Después, en el \cref{sec:solving_metaheuristics} se describen un conjunto de metaheurísticas basadas en la utilización de las heurísticas descritas en el apartado anterior de manera inteligente de tal manera que las configuraciones generadas proporcionan soluciones de mayor calidad. Por último, en el \cref{sec:solving_conclusions} se incluyen unas conclusiones generales acerca de los métodos de resolución aplicados al \emph{problema Dial-a-Ride}.

    \section{Métodos de Resolución Exactos}
    \label{sec:solving_exacts}

      \paragraph{}
      Los métodos de resolución exactos representan una de las categorías de resolución de problemas de optimización más interesantes debido a distintos factores, entre los que se encuentran aquellas situaciones en que es estrictamente necesario obtener el valor óptimo para una instancia dada. Sin embargo, esta categoría no solo es interesante por dicha razón, sino que el estudio de estos problemas además proporciona en muchas ocasiones razonamientos y justificaciones teóricas sobre el problema que pretenden resolver que ayudan a comprender mejor los factores del mismo. Lo interesante de este punto es que esto sirve de utilidad para el diseño de diferentes métodos de resolución así como su justificación.

      \paragraph{}
      Tal y como se ha descrito anteriormente, el método de resolución exacta más básico consiste en la enumeración de todas las configuraciones posibles dadas la variables de decisión del problema para después determinar como configuración óptima aquella que maximiza/minimiza la función objetivo. Esto es teóricamente posible por la naturaleza combinatoria del problema pero a la vez prácticamente imposible por la misma razón.

      \paragraph{}
      Puesto que los problemas de \emph{optimización combinatoria} se pueden modelar como problemas de \emph{optimización lineal} mediante un conjunto de restricciones de naturaleza lineal, la siguiente alternativa a la enumeración de configuraciones es la resolución como un problema de esta naturaleza. Para ello, una de las opciones es la utilización del algoritmos \emph{Simplex} \cite{klee1970good} tal y como se indica en el \cref{sec:formulation_linear_problems}. Como se ha descrito anteriormente, este algoritmo se basa en la búsqueda de la mejor solución contigua a la actual de manera iterativa hasta alcanzar aquella que no tenga una solución contigua mejor. Es posible demostrar que este algoritmo  alcanza el valor óptimo cuando se aplica sobre problema de \emph{optimización lineal}. Tal y como se puede apreciar en la \cref{img:solving_simplex}, gráficamente puede ser visto como la evaluación de vértices en un grafo de soluciones. La complejidad que esta estrategia presenta en problemas de \emph{optimización combinatoria} reside en el gran número de vértices que surgen del cambio de valor de cada una de las variables de decisión del problema, generando un grafo con gran número de vértices y aristas lo cual hace inalcanzable computacionalmente navegar por el mismo hasta alcanzar la solución óptima.

      \begin{figure}[ht]
        \centering
        \includegraphics[width=0.4\textwidth]{simplex-graphically}
        \caption{Representación gráfica del modo de ejecución del algoritmo \emph{Simplex}.}
        \label{img:solving_simplex}
      \end{figure}

      \paragraph{}
      Hasta ahora, en este apartado se ha descrito únicamente el proceso de resolución mediante algunos métodos exactos. Sin embargo, no se ha realizado ninguna particularización sobre el problema \emph{Dial-a-Ride}. Por tanto, es momento de definir el punto de enlace entre la definición del método y el problema en cuestión. Tal y como se ha descrito a lo largo del \cref{chap:formulation} el problema \emph{Dial-a-Ride} se enmarca dentro de los problemas de \emph{optimización lineal}. En la \cref{eq:formulation_basic_darp} se describe la formulación de $3$ índices para este problema, incluyendo tanto las variables de decisión como las restricciones que lo componen. En cuanto a la estrategia de enumeración, es fácil darse cuenta de que esta puede llevarse a cabo tomando todas las combinaciones posibles para las variables binarias del problema (lo cual tal y como se ha comentado anteriormente es algo inabordable en problemas no demostrativos). En cuanto a la estrategia de resolución basada en el algoritmo \emph{Simplex}, tal y como se ilustra en \cite{klee1970good} es posible construir la matriz simplex a partir de la matriz de restricciones generada por el problema en forma lineal.

      \paragraph{}
      A lo largo de la literatura relacionada con métodos de resolución exactos para el problema \emph{Dial-a-Ride}, existen un gran número de referencias basadas en el estudio de técnicas basadas en \emph{Branch and Bound} que tratan de tomar ventaja de alguna manera de la estructura del problema para así simplificar el camino hasta la solución óptima. En el siguiente apartado se describen de manera más detallada los conceptos en que se apoya este método.

      \subsection{Branch and Bound}
      \label{sec:solving_branch_bound}

        \paragraph{}
        Se pueden englobar en la categoría de algoritmos \emph{Branch and Bound} todos aquellos que basan su estrategia de resolución en comenzar por una versión relajada del problema base para posteriormente realizar un proceso jerarquico de cambios sobre la estructura del problema hasta alcanzar el valor óptimo del mismo. Esta estrategia es muy usada sobre problemas de \emph{optimización entera} ya que facilita en gran medida la problemática generada por las variables de decisión de carácter discreto del problema.

        \paragraph{}
        La estrategia habitual consiste en partir de una versión del problema sobre la cual las restricciones sobre variables discretas se han relajado a valores sobre intervalos. Es decir, supongamos que la variable de decisión $x$ únicamente puede tomar valores enteros entre $1$ y $5$, lo que es equivalente a $x \in \{1,2,3,4,5\}$. Entonces, una relajación lineal podría venir dada por la transformación en $1 \leq x \leq 5$ la cual es más sencilla de resolver por el algoritmo \emph{Simplex}. Posteriormente, el resto de pasos de ramificación consisten en añadir restriciones (mediante la generación de filas o columnas) que permitan satisfacer las restricciones del problema original.

        \begin{figure}[ht]
          \centering
          \includegraphics[width=0.4\textwidth]{branch-and-bound-tree}
          \caption{Ejemplo de ramificación del problema mediante el algoritmo \emph{Branch and Bound}.}
          \label{img:branch_and_bound}
        \end{figure}

        \paragraph{}
        Es importante tener en cuenta que las relajaciones aplicadas al problema inicial para aplicar el algoritmo \emph{Branch and Bound} no tienen por qué ser de naturaleza lineal, si no que se pueden aplicar sobre otros tipos de restricciones. Un ejemplo de ello se podría dar eliminando por ejemplo las restricciones de duración máximo de viaje en el problema \emph{Dial-a-Ride}, o la eliminación de restrcciones de ventana temporal en el problema \emph{Pickup and Delivery with Time Windows}. Una vez generada una solución factible sobre estos casos, el proceso de ramificación consistirá en \say{modificar} dicha solución hasta alcanzar aquella que cumpla todas las restricciones (de tiempo máximo de viaje, de ventanas temporales, etc.).

        \paragraph{}
        Dependiendo de la estrategia de ramificación del algoritmo, este se denomina de distintas maneras. Cuando la ramificación se basa en la generación de filas el algorimo se conoce como \emph{Branch and Cut}, mientras que si la estrategia se basa en la generación de columnas este se denomina \emph{Branch and Price}. Por último, cuando la estrategia se basa en la combinación de ambos entonces el algorimo es denominado \emph{Branch and Cut and Price}.

        \subsubsection{Branch and Cut}
        \label{sec:solving_branch_cut}

          \paragraph{}
          Tal y como se ha comentado anteriormente, los algoritmos \emph{Branch and Cut} consisten en una caracterización del algoritmo general de ramificación donde el proceso de \say{estrechamiento} de la versión relajada para cumplir con todas las restricciones impuestas por el problema viene dado por la adicción de planos de corte a partir de nuevas restricciones. Es por ello que este método se apoya en estrategias de generación de filas.

          \paragraph{}
          Para el caso del problema \emph{Dial-a-Ride}, en \cite{cordeau2006branch} se propone una implementación completa basada en el algoritmo \emph{Branch and Cut} la cual se apoya en la generación inicial de una solución del problema relajado (para el cual se eliminan las restricciones que imponen variables de decisión binarias, permitiendo que estas tomen cualquier valor en el intervalo $[0, 1]$) para posteriormente, a partir de un proceso de ramificación añadir restricciones adiccionales que fuerzan a las variables de naturaleza binaria con valores no binarios a tomar un valor válido (ahí surge el proceso de ramificación). Para detectar sobre qué variable concreta generar el corte en cada caso, la estrategia seguida se apoya en la definición de unas heurísticas que generan una lista ordenada sobre la cual seleccionar dicha variable. En la línea de este enfoque, también es interesante remarcar \cite{ropke2007models} donde además se propone un modelo de programación lineal basado en 2 índices, que a pesar de no representar el mismo caso que el problema \emph{Dial-a-Ride}, sus diferencias son mínimas (número indeterminado de vehículos, todos los vehículos con misma capacidad, etc.).

        \subsubsection{Branch and Price}
        \label{sec:solving_branch_price}

          \paragraph{}
          Del mismo modo que el método \emph{Branch and Cut} es una estrategia de generación de filas enmarcada dentro de la familia de algoritmos \emph{Branch and Bound}, el método \emph{Branch and Price} es la versión correspondiente cuya estrategia se basa en la generación de columnas sobre la matriz de restricciones del problema de programación lineal. Es decir, se basa en la inclusión de nuevas variables sobre una versión relajada del problema inicial. Puesto que puede dar lugar a confusión, es necesario detallar cómo se puede llevar esto a cabo para reflejar de manera adecuada la diferencia respecto del método de generación de filas. Mientras que en la estrategia de generación de filas, la relajación se produce permitiendo que las variables de decisión tomen valores que no satisfacen las restricciones originales, en este caso el enfoque consiste en resolver una versión más simple del problema original para después, mediante un proceso iterativo, ampliar el alcance del problema simplificado hasta alcanzar la definición del mismo que satisfaga todas las restricciones de la versión original. El proceso de ramificación surge cuando no es posible satisfacer las condiciones impuestas tras la inclusión de nuevas variables, donde esta es forzada con la esperanza de que sea satisfecha en la siguiente iteracción, creando una ramificación por cada posible alternativa.

          \paragraph{}
          Aplicado al problema \emph{Dial-a-Ride}, una posible estrategia se apoya en limitar los aristas disponibles del grafo en una primera iteracción, para posteriormente aplicar un proceso inclusión/eliminación de aristas del grafo para así controlar la complejidad del problema a la vez que se exploran distintas soluciones. El proceso de ramificación de soluciones surge cuando son eliminados aristas que en alguna de las soluciones hayan sido utilizados. Para llevar a cambo dicho proceso de inclusión/eliminación en la literatura se han propuesto estragias apoyadas en \emph{Programación dinámica}.

        \subsubsection{Branch and Cut and Price}
        \label{sec:solving_branch_cut_price}

          \paragraph{}
          Una vez descritos lo métodos basados en generación de filas (\emph{Branch and Cut}) así como de columnas (\emph{Branch and Price}), es fácil entender el funcionamiento del método \emph{Branch and Cut and Price}, que se apoya en la combinación de ambas estrategias para reducir así reducir la complejidad de resolución del problema \emph{Dial-a-Ride}. Como es natural, estos cuentan con la ventaja de resolver instancias más fáciles de resolver del problema por tener un menor número de restricciones (eliminación de filas) así como de hacerlo sobre versiones más pequeñas del problema (eliminación de columnas). Tal y como se ha podido comprobar en distintas publicaciones que comparan la utilización de los métodos de generación de filas o columnas de manera separada, frente a las correspondientes versiones combinadas, estas últimas obtienen un nivel de resultados equivalente requiriendo de un menor nivel de cómputo. 

      \paragraph{}
      Tal y como se ha podido comprobar a lo largo del apartado, los métodos de resolución apoyados por técnicas basadas en ramificación son capaces de ofrecer ventajas relacionadas con la simplicación del problema completo a resolver a costa de requerir la resolución de múltiples versiones relajadas de distintas formas de dicho problema. Cuando el tamaño de la instancia del problema es tan grande que esta no puede ser resuelta \say{de una sola vez}, estos métodos ofrecen una alternativa interesante por seguir ofreciendo garantías de optimalidad, lo cual en ciertos casos es un requisito necesario.

    \section{Métodos de Resolución basados en Heurísticas}
    \label{sec:solving_heuristics}

      \paragraph{}
      Tal y como se ha explicado anteriormente, los problemas de optimización combinatoria se corresponden en la mayoría de ocasiones con problemas cuya complejidad desde el punto de vista de la resolución no es sencilla. Tal es así que muchos de estos se engloban dentro de la categoría de problemas $NP$, lo cual se puede resumir como aquellos para los cuales no existe una estrategia de resolución exacta que alcance el resultado óptimo en tiempo polinómico. Esto implica que para instancias no demasiado grandes no sea factible alcanzar dicho resultado en un tiempo aceptable. 

      \paragraph{}
      Para paliar esta problemática, surgen métodos de resolución denominados \emph{estrategias heurísticas}. Estas se caracterizan por ser capaces de proporcionar resultados razonablemente cercanos a solución óptima empleando para ello una cantidad de recursos (generalmente tiempo de cómputo) significativamente menor a la que requerirían otras estrategias con ganarantías de optimalidad. Este es un compromiso aceptable cuando no es posible llegar a soluciones de otro modo. Por lo tanto, uno de los grandes objetivos de la investigación y el desarrollo de heurísticas consiste en implementar algoritmos que sean capaces de alcanzar soluciones lo más cercanas a la solución óptima, teniendo en cuenta las restricciones de tiempo para que estas puedan ser alcanzadas.

      \paragraph{}
      Desde una perspectiva de alto nivel, los métodos de resolución basados en heurísticas típicamente son clasificados en dos grandes categorías según la función que desempeñan, las cuales se conocen como \emph{heurísticas de construcción} y \emph{heurística de mejora}. A pesar de que su nombre es lo suficientemente explicativo, a continuación se detalla la función que representan los métodos pertenecientes a cada una de estas categorías:
      
      \begin{itemize}
          
          \item \textbf{Heurísticas de Construcción}: la función que desempeñan consiste en la generación de soluciones sin el apoyo de ningún estado previo. Es decir, recibiendo únicamente los valores de entrada necesarios para la formulación del problema, estas son capaces de generar soluciones del problema que satisfacen todas las restricciones impuestas por la formulación del mismo. En el caso de los problemas de rutas de vehículos, estas estrategias se apoyan comúnmente en algorimos de insercción inspirados en algoritmos greedy y, en algunas ocasiones con un cierto nivel de aleatoriedad. Por lo general, los resultados a los que es posible llegar utilizando únicamente estrategias de este tipo, no son lo suficientemente cercanas al resultado óptimo. Para resolver esta problemática, existen otras estrategias que tratan de paliar esta situación.

          \item \textbf{Heurísticas de Mejora}: debido al grado de dificultad necesario para tomar las decisiones más acertadas durante el proceso de construcción de soluciones, la categoría de \emph{heurísticas de mejora} trata de mejorar la calidad una solución dada. Para ello, como es esperable, estas estrategias necesitan conocer tanto el conjunto de valores de entrada necesarios para la formulación del problema, como una solución inicial del mismo. A partir de estas dos partes, el modo de funcionamiento consiste en aplicar distintas modificaciones a la solución para así tratar de maximizar (o minimizar) el valor de la función objetivo, lo cual acerca dicha solución al valor óptimo deseado. A este modo de funcionamiento se le conoce como búsqueda local dentro del espacio de soluciones. En el caso de los problemas de rutas de vehículos, las estrategias en que se basan consisten en la aplicación de operadores tales como el intecambio de tareas (o viajes) entre distintos vehículos, cambio del orden dentro del mismo vehículo, etc. Por tanto, el objetivo se trata de buscar el conjunto de transformaciones de la solución que permitan un mayor acercamiento al resultado esperado al final de la ejecución. Esta última afirmación se explicará más en detalle en el \cref{sec:solving_greedy}
      
      \end{itemize}


      \paragraph{}
      Una vez se han detallado las diferencias entre las dos categorías principales de estrategias de resolución basados en heurísticas, se está en condiciones suficientes como para explicar en detalle algunos de los algoritmos concretos a través de los cuales es posible alcanzar dichas soluciones. El resto del apartado se estructura de la siguiente forma: en el \cref{sec:solving_brute_force} se detalla la estrategia basada en \emph{fuerza bruta} (la cual como veremos no es aplicable en la práctica en la gran mayoría de casos). Seguidamente, en el \cref{sec:solving_random} está dedicado a la estrategia basada en \emph{selección aleatoria}. Después se describirá en detalle la estrategia basada en \emph{algoritmos greedy} (la cual es muy popular por su sencillez conceptual y relativamente buenos resultados). Posteriormente, se comentará la estrategia basada en el \emph{algoritmo metrópolis-hastings} en el \cref{sec:solving_metropolis} y finalmente se discutirá el funcionamiento de la \emph{clarke and wright} y un método basado en \emph{mapas auto-organizados (SOM)} en los \cref{sec:solving_clarke_and_wright,sec:solving_som} 

      \subsection{Fuerza Bruta}
      \label{sec:solving_brute_force}
        
        \paragraph{}
        A pesar de que anteriormente se ha comentado que una de las grandes diferencias entre métodos de resolución exactos y métodos de resolución basados en heurísticas son las garantías de optimalidad, esta distinción es un tanto difusa cuando se tratan de clasificar las estrategias de fuerza bruta. Esto se debe a que, si bien es cierto que esta estrategia es capaz de garantizar resultados óptimos cuando termina, la estrategia de resolución se encuentra más próxima a los algoritmos heurísticos que a los métodos que hemos clasificado como exactos, puesto que estos se apoyan en mayor medida en la teoría de programación lineal, mientras que las estrategias heurísticas tienden a acercarse más a estrategias algorítmicas clásicas. Para una descripción más detallada y profunda del tema se recomienda consultar \cite{cormen2009introduction}.

        \paragraph{}
        Una vez aclarada la peculiaridad de la estrategia de \emph{fuerza bruta}, procedemos a describir en qué se basa: El modo de funcionamiento consiste en la enumeración de todas las posibles configuraciones, para después proceder a filtrar todas aquellas que sean factibles, y de entre estas, escoger aquella que maximize (o minimize) la función objetivo. La definición de esta estrategia en pseudo código se incluye en el \cref{code:solving_brute_force} (donde $U$ representa el universo de posibles solucions, $feasible$ se trata de una función que recibe una solución y se encarga de evaluar si es o no factible, $F$ se compone de todas las soluciones factibles y por último, $s$ se corresponde con la solución óptima, que en este caso se trata de un problema de minimización).

        \begin{algorithm}[ht]
          \SetAlgoLined
          \KwResult{$s$ }
          $F \gets filter(feasible, U)$\;
          $s \gets min\{F\}$\;
          \caption{Estrategia de resolución basada en \emph{fuerza bruta}.}
          \label{code:solving_brute_force}
        \end{algorithm}

        \paragraph{}
        Sin embargo, tal y como se puede intuir, esta estrategia de resolución requiere de una cantidad de recursos que crece de manera exponencial respecto del tamaño de entrada. Por lo tanto, no es aplicable en la práctica sobre problemas de gran tamaño. Aún así, existen ciertos problemas para los cuales el grado de complejidad es relativamente bajo o el tamaño de las instancias a resolver es pequeño, por lo que esta estrategia es aplicable. En dichos casos, esta es una alternativa interesante ya que, como se ha comentado anteriormente, los algoritmos basados en \emph{fuerza bruta} proporcionan garantías de optimalidad.  

        \paragraph{}
        Una de las ventajas de los métodos de resolución basado en fuerza bruta es la capacidad de poder aprovecharse de la estructura del problema concreto que se pretende resolver para así poder reducir el espacio de búsqueda de soluciones en gran medida. Esto se debe a que el espacio de posibles soluciones factibles es un subconjunto del espacio de posibles soluciones. Por tanto, si se consigue encontrar alguna estrategia que permita enfocarse únicamente en las soluciones factibles, los requerimientos computacionales serán mucho menores. Un ejemplo de ello podría aplicarse a una estrategía de generación de soluciones en problemas de rutas a partir de una estrategia de inserción al final de la ruta. Entonces, es fácil darse cuenta de que si durante el proceso de inserción de tareas en la ruta, se llega a un estado de infactibilidad, continuar el proceso de insertar nuevas tareas al final de la ruta, continuará generando soluciones infactibles. Por tanto, en este caso es posible reducir el espacio de búsqueda sin perder las garantías de optimalidad. 

      \subsection{Selección Aleatoria}
      \label{sec:solving_random}

        \paragraph{}
        La siguiente estrategia heurística a comentar se presenta en muchos sentidos como una versión opuesta a la de \emph{fuerza bruta}. Esta es la heurística basada en \emph{selección aleatoria}, cuya principal característica es el apoyo en una componente de estocasticidad que pretende, a largo plazo, alcanzar resultados razonables utilizando para ello un reducido coste computacional. Entonces, tal y como se puede intuir esta estrategia es opuesta a la de \emph{fuerza bruta} en dos sentidos: \begin{enumerate*}[label=(\arabic*)] \item la búsqueda en el espacio de soluciones no es exhaustiva, por lo que no se prueban todos los casos posibles (lo cual elimina las garantías de optimalidad) y \item el coste computacional que conlleva generar soluciones factibles es mucho menor puesto que la decisión sobre qué camino explorar se delega en selección aleatoria \end{enumerate*}.

        \paragraph{}
        Tal y como se puede apreciar en el \cref{code:solving_random_selection}, la estrategia se basa en generar soluciones aleatorias del universo de posibles soluciones para después evaluar la factibilidad de la escogida en cada iteracción y almacenarla en caso de que esta maximice (o minimice) el valor de la función objetivo. Esto se repite mientras se cumpla una determinada condición, la cual puede basarse en un determinado número de iteracciones, una cantidad de tiempo o estrategias más elaboradas como un determinado ratio de mejora respecto entre la última mejor solución obtenida y la anterior, etc.

        \begin{algorithm}[ht]
          \SetAlgoLined
          \KwResult{$s$ }
          $s \gets \emptyset$\;
          \While{$condition$}{
              $c \gets random(U)$\;
              \If{$!feasible(c)$}{
                  \Continue\;
              }
              $s \gets min(s, c)$\;
          }
          \caption{Estrategia de resolución basada en \emph{selección aleatoria}.}
          \label{code:solving_random_selection}
        \end{algorithm}

        \paragraph{}
        Tal y como se puede intuir, por si sola esta heurística no es todo lo eficiente como se espera para ser aplicable en la práctica puesto que, a pesar de la simplicidad que proporciona durante el proceso de generación y evaluación de soluciones, resulta muy improbable que llegue a alcanzar soluciones razonables sin que la estrategia se apoye en cierto conocimiento del problema. Sin embargo, tal y como se comentará más adelante, esta estrategia sirve como base (o componente) de otras mucho más elaboradas que consiguen alcanzar resultados mucho mejores en el largo plazo mediante la utilización de cierta componente aleatoria en alguna parte del proceso de optimización. Desde el punto de vista conceptual, hacer esto consigue añadir cierto ruido en el camino de búsqueda hacia la solución óptima que puede ser positivo dado que este reduce la complicación de \say{caer} en máximos (o mínimos) locales que en ciertas estrategias heurísticas complican en gran medida el proceso de optimización.

      \subsection{Greedy}
      \label{sec:solving_greedy}

        \paragraph{}
        Una de las estrategias más conocidas (por su buena relación entre sencillez y calidad de las soluciones) son las basadas en \emph{algorithmos greedy}. Estos se corresponden con una de las principales categorías en las cuales se suelen dividir los algoritmos en la mayoría de libros de relacionados. La principal característica de este tipo de algoritmos es que cada una de las decisiones que toman se convierten en invariantes para los próximos pasos que lleve a cabo la estrategia en la búsqueda de la solución final. De ahí el nombre \emph{greedy} (o voraz en español), que trata de remarcar la idea de que cada una de las decisiones que tomadas terminarán formando parte de la solución final. Nótese que esta condición conlleva dos consecuencias principales \begin{enumerate*}[label=(\arabic*)] \item la simplicidad tanto a nivel conceptual como conceptual al requerir únicamente del estado actual (obtenido a partir de las decisiones tomadas anteriormente y las alternativas actualmente posibles), y \item la restricción de reevaluar decisiones anteriores que permitirían llegar a una solución más acercada con el conocimiento obtenido en el momento actual \end{enumerate*}.

        \paragraph{}
        Sin embargo, existen ciertos problemas que poseen ciertas características que permiten que los algoritmos de naturaleza voraz sean capaces de llegar al resultado correcto (u óptimo dependiendo de la naturaleza del problema) de manera eficiente y a la vez sencilla. El ejemplo más notable es el de el \emph{problema del cajero}. Dicho problema consiste en la elección sobre qué monedas utilizar de entre un conjunto dado de posibles valores (los cuales no tienen restricciones de cardinalidad) de tal manera que el número de monedas que sea mínimo. A modo de ejemplo, suponiendo el conjunto de valores posibles $\{1,5,10, 25, 100\}$, la asignación que minimiza el número de monedas para devolver el valor $34$ es de $[25, 5, 1, 1, 1, 1]$. La estrategia para llegar a esta solución consiste en seleccionar siempre la moneda de mayor valor que no supere el resto necesario para llegar al valor deseado. En el \cref{code:solving_greedy} se muestra el pseudo código de la estrategia, donde $S$ representa la solución, $v$ el valor deseado, $C$ el conjunto de posibles monedas y $c$ una variable temporal. Tal y como se puede apreciar, siguiendo esta estrategia se cumplen las condiciones requeridas po los \emph{algoritmos de naturaleza voraz} ya que únicamente se tiene en cuenta el estado actual para tomar la siguiente decisión y no se modifican las decisiones tomadas anteriormente. Para más información acerca de las características de esta categoría algorítmica así como ejemplos más interesantes se recomienda consultar \emph{cormen2009introduction}.

        \begin{algorithm}[ht]
          \SetAlgoLined
          \KwResult{$S$ }
          $S \gets [] $\;
          \While{$v \neq 0$}{
            $c \gets min_{v - c > 0}\{C\}$\;
            $v \gets v - c $\;
            $S \gets S + [ c ]$\;
          }
          \caption{Estrategia de resolución del \emph{problema del cajero} basada en \emph{algoritmo greedy}.}
          \label{code:solving_greedy}
        \end{algorithm}

        \paragraph{}
        Desde el punto de vista de los problemas de optimización combinatoria, los \emph{algoritmos de naturaleza voraz} han sido de gran utilidad para muchas situaciones. Sin embargo, tal y como se puede intuir, estos requieren que el problema sobre el que se van a aplicar cumpla la propiedad de ser concavos (una mejora sobre una solución arbitraria en la dirección de la solución óptima garantiza un menor coste en la función objetivo) para que estos puedan alcanzar la solución óptima. Por contra, esto ocurre en muy pocas ocasiones en la mayoría de problemas de optimización combinatoria. Si bien es cierto, hay casos para los cuales esta condición si se cumple (como el problema del cajero), pero en muchos otros (entre los que se encuentran los \emph{problemas de rutas de vehículos}) esta condición no se satisface.  

        \paragraph{}
        [TODO]

        \subsubsection{Criterios de Selección}
        \label{sec:solving_greedy_criterions}

          \paragraph{}
          [TODO]

        \subsubsection{Randomized Greedy}
        \label{sec:solving_randomized_greedy}

          \paragraph{}
          [TODO]

      \subsection{Metropolis Hastings}
      \label{sec:solving_metropolis}

        \paragraph{}
        [TODO]

      \subsection{Clarke and Wright}
      \label{sec:solving_clarke_and_wright}

        \paragraph{}
        [TODO]

      \subsection{SOM}
      \label{sec:solving_som}

        \paragraph{}
        [TODO]

      \paragraph{}
      [TODO]

    \section{Métodos de Resolución basados en Metaheurísticas}
    \label{sec:solving_metaheuristics}

      \paragraph{}
      [TODO]

      \subsection{GRASP}
      \label{sec:solving_grasp}

        \paragraph{}
        [TODO]

      \subsection{Simulated Anneling}
      \label{sec:solving_simulated_anneling}

        \paragraph{}
        [TODO]

      \subsection{Tabu Search}
      \label{sec:solving_tabu}

        \paragraph{}
        [TODO]

      \subsection{Ant Colony}
      \label{sec:solving_ant_colony}

        \paragraph{}
        [TODO]

      \subsection{Variable Neighborhood Search}
      \label{sec:solving_vns}

        \paragraph{}
        [TODO]

      \subsection{Large Neighborhood Search}
      \label{sec:solving_lns}

        \paragraph{}
        [TODO]

      \paragraph{}
      [TODO]

    \section{Conclusiones}
    \label{sec:solving_conclusions}

      \paragraph{}
      [TODO]

\end{document}
